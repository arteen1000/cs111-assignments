Lab 1
-----

Code used by the pipe | operator

Our program:

./pipe ls cat wc # my program
Ls | cat | wc # system implementation -> words defined by IFS

3 sub-components to do Lab 1:

- first need to be able to run a single program
- second want to ensure correct ordering

./pipe a b c d e f
a | b | c | d | e | f

- read and execute the programs represented by arguments
- execution ordering aligns with the arguments
-create a pipe between two adjacent programs
 -> argv[i]'s output to argv[i+1]'s input

- no options to programs
- easy to check correctness, simply test equality

step 1:
- read and execute the programs
 int argc, char *argv[]
 argv[0] is program name, argv[1] - argv[argc-1] are program arguments
- can use fork and execlp to create proesses
 execlp("executable filename", "again", "however many args you like, comma sep", NULL); # end argv with NULL
  if (execlp("ls", "ls", NULL) == -1) return errno;

  pid_t fork(void) -> creates new process (child) by duplicating the calling process (parent)
	child has almost same state
  return < 0 is an error
  return 0 to the child process
  return pid of child process to parent process

  pid_t wait(int *wstatus) -> blocks calling process until any one of its child processes exit or signal received, afterward calling processes continue execution
	-> returns pid of process that terminated
  
  pid_t waitpid(pid_t, int *wstatus, int options);
	-> waits until child with that pid terminates

  ex.
	int return_code = fork();
	if (return_code > 0) {
		int pid = return_code;
		int status = 0;
		waitpid(pid, &status, 0);
		... WEXITSTATUS(status) -> interprets it, return value of child process
	}


- need to create pipe between two adjacent programs

argv[i]'s output to argv[2]'s input

stdin (keyboard), stdout(screen), stderr(screen) for the shell

File descriptors -> everything is abstracted as a file
	-> make syscall to request access to them
	syscalls return file descriptors as a handle for files

want to set a program's stdout to be a specific fd of a file on disk, redirection
	> 
set a program's stdin to be specific fd of a file on disk
	<
now how do we route between them?

programs across pipe? could create an in-memory buffer, and not run them parallel, and just do it that way.

Wriite data -> Pipe Buffer -> Reading data
where -> is a descriptor

pipe() syscall fds[0] is file descriptor for read end, fds[1] is file descriptor for write end, 0 on success, -1 on error

Will set errno to indicate

ex.

int fds[2];
pipe(fds);

int ret = fork()

if (ret == 0) {
	write(fds[1], "hello, parent!", 14);
	sleep(5); // race condition?
	write(fds[1], "just one more thing!", 21);
} else if (ret > 0) {
	char buffer[4096];
	read(fds[0], buffer, 35);
	printf("%s\n", buffer);
} // pipe will wait for subsequent reads

need to print the output of last to terminal

stdin -> program1 -> pipe buffer -> program2 -> pipe buffer -> program3 -> terminal (output to terminal)

i/o redirection with dup2
#include <unistd.h>
int dup2(int target_fd, int prev_fd);
dup() uses lowest-numbered unused file descriptor
dup2() redirects a specific file descriptor

File Descriptor
---------------
File descriptors are handles/references to underlying files
-> pass file descriptor to kernel via syscall to do useful work for you

-> small unsigned int that identifies a OS resource (an open file) -> kernel-made

Generally unique, can share across process:

 - dup() will create copy of fd, adds one more file descriptor and grabs the lowest available number for file descriptor, dup2(old, new) does a specific assignment

0 --> tty
1 --> tty
2 --> tty

Ex. Want to redirect stdout, would do

1 --> tty (close connection)
dup(write end of pipe)
1 --> write end of pipe

Same as doing

dup2(write end of pipe, 1)

